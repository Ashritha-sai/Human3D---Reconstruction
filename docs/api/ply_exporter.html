<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ply_exporter API documentation</title>
<meta name="description" content="PLY Exporter for Gaussian Splatting …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ply_exporter</code></h1>
</header>
<section id="section-intro">
<p>PLY Exporter for Gaussian Splatting</p>
<p>This module provides functionality to export 3D Gaussian splats to PLY format,
compatible with standard Gaussian Splatting viewers and the original
3D Gaussian Splatting implementation.</p>
<p>The PLY format stores per-Gaussian attributes:
- Position (xyz)
- Spherical harmonic coefficients (DC + optional higher orders)
- Opacity
- Scale (3D log-scale)
- Rotation (quaternion)</p>
<h2 id="references">References</h2>
<ul>
<li>Original 3DGS PLY format: <a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></li>
<li>PLY specification: <a href="http://paulbourke.net/dataformats/ply/">http://paulbourke.net/dataformats/ply/</a></li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ply_exporter.construct_ply_header"><code class="name flex">
<span>def <span class="ident">construct_ply_header</span></span>(<span>num_vertices: int, sh_degree: int = 0, extra_properties: Optional[list] = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_ply_header(
    num_vertices: int,
    sh_degree: int = 0,
    extra_properties: Optional[list] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Construct PLY header string for Gaussian splat data.

    Args:
        num_vertices: Number of Gaussians (vertices).
        sh_degree: Spherical harmonic degree (0-3).
            0: 1 coefficient (DC only)
            1: 4 coefficients
            2: 9 coefficients
            3: 16 coefficients (full)
        extra_properties: List of (name, dtype) tuples for extra attributes.

    Returns:
        str: Complete PLY header including &#34;end_header\n&#34;.

    Example:
        &gt;&gt;&gt; header = construct_ply_header(1000, sh_degree=0)
        &gt;&gt;&gt; print(header[:50])  # &#34;ply\nformat binary_little_endian 1.0\n...&#34;
    &#34;&#34;&#34;
    lines = [
        &#34;ply&#34;,
        &#34;format binary_little_endian 1.0&#34;,
        f&#34;element vertex {num_vertices}&#34;,
        &#34;property float x&#34;,
        &#34;property float y&#34;,
        &#34;property float z&#34;,
        &#34;property float nx&#34;,
        &#34;property float ny&#34;,
        &#34;property float nz&#34;,
        &#34;property float f_dc_0&#34;,
        &#34;property float f_dc_1&#34;,
        &#34;property float f_dc_2&#34;,
    ]

    # Add f_rest properties based on SH degree
    num_sh_coeffs = get_sh_coefficient_count(sh_degree)
    num_rest = (num_sh_coeffs - 1) * 3  # -1 for DC, *3 for RGB
    for i in range(num_rest):
        lines.append(f&#34;property float f_rest_{i}&#34;)

    # Add remaining properties
    lines.extend([
        &#34;property float opacity&#34;,
        &#34;property float scale_0&#34;,
        &#34;property float scale_1&#34;,
        &#34;property float scale_2&#34;,
        &#34;property float rot_0&#34;,
        &#34;property float rot_1&#34;,
        &#34;property float rot_2&#34;,
        &#34;property float rot_3&#34;,
    ])

    # Add extra properties
    if extra_properties:
        for name, dtype in extra_properties:
            lines.append(f&#34;property {dtype} {name}&#34;)

    lines.append(&#34;end_header&#34;)

    return &#34;\n&#34;.join(lines) + &#34;\n&#34;</code></pre>
</details>
<div class="desc"><p>Construct PLY header string for Gaussian splat data.</p>
<pre><code>Args:
    num_vertices: Number of Gaussians (vertices).
    sh_degree: Spherical harmonic degree (0-3).
        0: 1 coefficient (DC only)
        1: 4 coefficients
        2: 9 coefficients
        3: 16 coefficients (full)
    extra_properties: List of (name, dtype) tuples for extra attributes.

Returns:
    str: Complete PLY header including "end_header
</code></pre>
<p>".</p>
<pre><code>Example:
    &gt;&gt;&gt; header = construct_ply_header(1000, sh_degree=0)
    &gt;&gt;&gt; print(header[:50])  # "ply
</code></pre>
<p>format binary_little_endian 1.0
&hellip;"</p></div>
</dd>
<dt id="ply_exporter.get_sh_coefficient_count"><code class="name flex">
<span>def <span class="ident">get_sh_coefficient_count</span></span>(<span>degree: int) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sh_coefficient_count(degree: int) -&gt; int:
    &#34;&#34;&#34;
    Get the number of spherical harmonic coefficients for a given degree.

    Args:
        degree: SH degree (0-3).

    Returns:
        int: Number of coefficients = (degree + 1)²
            degree 0: 1
            degree 1: 4
            degree 2: 9
            degree 3: 16
    &#34;&#34;&#34;
    return (degree + 1) ** 2</code></pre>
</details>
<div class="desc"><p>Get the number of spherical harmonic coefficients for a given degree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>degree</code></strong></dt>
<dd>SH degree (0-3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of coefficients = (degree + 1)²
degree 0: 1
degree 1: 4
degree 2: 9
degree 3: 16</dd>
</dl></div>
</dd>
<dt id="ply_exporter.load_gaussian_ply"><code class="name flex">
<span>def <span class="ident">load_gaussian_ply</span></span>(<span>filepath: Union[str, Path]) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_gaussian_ply(
    filepath: Union[str, Path],
) -&gt; dict:
    &#34;&#34;&#34;
    Load Gaussian splats from PLY file.

    Reads a PLY file in the 3D Gaussian Splatting format and returns
    all Gaussian parameters as NumPy arrays.

    Args:
        filepath: Path to the PLY file.
            Must exist and be readable.

    Returns:
        dict: Dictionary containing Gaussian parameters:
            - &#39;means&#39;: (N, 3) float32 - positions
            - &#39;scales&#39;: (N, 3) float32 - log-scales
            - &#39;rotations&#39;: (N, 4) float32 - quaternions (wxyz)
            - &#39;sh_coeffs&#39;: (N, num_coeffs, 3) float32 - SH coefficients
            - &#39;opacities&#39;: (N,) float32 - opacity values
            - &#39;num_gaussians&#39;: int - total count

    Raises:
        FileNotFoundError: If file does not exist.
        ValueError: If file format is invalid.

    Example:
        &gt;&gt;&gt; data = load_gaussian_ply(&#34;trained_model/point_cloud.ply&#34;)
        &gt;&gt;&gt; print(f&#34;Loaded {data[&#39;num_gaussians&#39;]} Gaussians&#34;)
        &gt;&gt;&gt; print(f&#34;Position range: {data[&#39;means&#39;].min():.2f} to {data[&#39;means&#39;].max():.2f}&#34;)
    &#34;&#34;&#34;
    from plyfile import PlyData

    filepath = Path(filepath)
    if not filepath.exists():
        raise FileNotFoundError(f&#34;PLY file not found: {filepath}&#34;)

    # Read PLY file
    plydata = PlyData.read(str(filepath))
    vertex = plydata[&#39;vertex&#39;]
    n_gaussians = len(vertex)

    # Extract positions
    means = np.stack([
        vertex[&#39;x&#39;],
        vertex[&#39;y&#39;],
        vertex[&#39;z&#39;],
    ], axis=1).astype(np.float32)

    # Extract scales
    scales = np.stack([
        vertex[&#39;scale_0&#39;],
        vertex[&#39;scale_1&#39;],
        vertex[&#39;scale_2&#39;],
    ], axis=1).astype(np.float32)

    # Extract rotations
    rotations = np.stack([
        vertex[&#39;rot_0&#39;],
        vertex[&#39;rot_1&#39;],
        vertex[&#39;rot_2&#39;],
        vertex[&#39;rot_3&#39;],
    ], axis=1).astype(np.float32)

    # Extract opacities
    opacities = np.array(vertex[&#39;opacity&#39;]).astype(np.float32)

    # Extract SH coefficients
    # First, get DC terms
    f_dc = np.stack([
        vertex[&#39;f_dc_0&#39;],
        vertex[&#39;f_dc_1&#39;],
        vertex[&#39;f_dc_2&#39;],
    ], axis=1).astype(np.float32)  # (N, 3)

    # Count f_rest properties
    # vertex.data.dtype.names gives the property names
    property_names = vertex.data.dtype.names
    f_rest_names = [p for p in property_names if p.startswith(&#39;f_rest_&#39;)]
    num_rest = len(f_rest_names)

    if num_rest &gt; 0:
        # Sort by index
        f_rest_names = sorted(f_rest_names, key=lambda x: int(x.split(&#39;_&#39;)[-1]))
        f_rest = np.stack([vertex[name] for name in f_rest_names], axis=1).astype(np.float32)
        # Reshape: (N, num_rest) -&gt; (N, num_rest//3, 3)
        f_rest = f_rest.reshape(n_gaussians, -1, 3)
        # Combine DC and rest
        sh_coeffs = np.concatenate([f_dc[:, np.newaxis, :], f_rest], axis=1)
    else:
        sh_coeffs = f_dc[:, np.newaxis, :]  # (N, 1, 3)

    return {
        &#39;means&#39;: means,
        &#39;scales&#39;: scales,
        &#39;rotations&#39;: rotations,
        &#39;sh_coeffs&#39;: sh_coeffs,
        &#39;opacities&#39;: opacities,
        &#39;num_gaussians&#39;: n_gaussians,
    }</code></pre>
</details>
<div class="desc"><p>Load Gaussian splats from PLY file.</p>
<p>Reads a PLY file in the 3D Gaussian Splatting format and returns
all Gaussian parameters as NumPy arrays.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to the PLY file.
Must exist and be readable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing Gaussian parameters:
- 'means': (N, 3) float32 - positions
- 'scales': (N, 3) float32 - log-scales
- 'rotations': (N, 4) float32 - quaternions (wxyz)
- 'sh_coeffs': (N, num_coeffs, 3) float32 - SH coefficients
- 'opacities': (N,) float32 - opacity values
- 'num_gaussians': int - total count</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If file does not exist.</dd>
<dt><code>ValueError</code></dt>
<dd>If file format is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; data = load_gaussian_ply(&quot;trained_model/point_cloud.ply&quot;)
&gt;&gt;&gt; print(f&quot;Loaded {data['num_gaussians']} Gaussians&quot;)
&gt;&gt;&gt; print(f&quot;Position range: {data['means'].min():.2f} to {data['means'].max():.2f}&quot;)
</code></pre></div>
</dd>
<dt id="ply_exporter.save_gaussian_ply"><code class="name flex">
<span>def <span class="ident">save_gaussian_ply</span></span>(<span>means: np.ndarray,<br>scales: np.ndarray,<br>rotations: np.ndarray,<br>sh_coeffs: np.ndarray,<br>opacities: np.ndarray,<br>filepath: Union[str, Path],<br>extra_attributes: Optional[dict] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_gaussian_ply(
    means: np.ndarray,
    scales: np.ndarray,
    rotations: np.ndarray,
    sh_coeffs: np.ndarray,
    opacities: np.ndarray,
    filepath: Union[str, Path],
    extra_attributes: Optional[dict] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Save Gaussian splats to PLY file format.

    Exports trained Gaussian parameters to a binary PLY file compatible
    with standard 3D Gaussian Splatting viewers and renderers.

    Args:
        means: Gaussian center positions in world coordinates.
            Shape: (N, 3)
            dtype: float32
            Units: Meters
            Columns: [x, y, z]

        scales: Log-scale parameters for each axis.
            Shape: (N, 3)
            dtype: float32
            Range: Typically [-10, 2] in log-space
            Note: Actual scale = exp(scales)
            Columns: [scale_x, scale_y, scale_z]

        rotations: Rotation quaternions in (w, x, y, z) format.
            Shape: (N, 4)
            dtype: float32
            Should be normalized (||q|| = 1)
            Columns: [rot_w, rot_x, rot_y, rot_z]

        sh_coeffs: Spherical harmonic coefficients for color.
            Shape: (N, num_coeffs, 3) where num_coeffs = (degree+1)²
            dtype: float32
            For degree 0: shape (N, 1, 3) - DC term only
            For degree 3: shape (N, 16, 3) - full SH

            The DC term (sh_coeffs[:, 0, :]) encodes base color.
            Higher-order terms encode view-dependent effects.

        opacities: Opacity values after sigmoid activation.
            Shape: (N,) or (N, 1)
            dtype: float32
            Range: [0, 1] (already activated, not logits)

        filepath: Output path for the PLY file.
            Will create parent directories if needed.
            Should have .ply extension.

        extra_attributes: Optional dictionary of additional per-Gaussian attributes.
            Keys: Attribute names (will be prefixed with &#34;extra_&#34;)
            Values: np.ndarray of shape (N,) or (N, k)
            Default: None

    Raises:
        ValueError: If input shapes are incompatible.
        IOError: If file cannot be written.

    File Format:
        The PLY file contains a header followed by binary vertex data.

        Header example:
            ply
            format binary_little_endian 1.0
            element vertex &lt;N&gt;
            property float x
            property float y
            property float z
            property float f_dc_0
            property float f_dc_1
            property float f_dc_2
            property float f_rest_0
            ... (up to f_rest_44 for degree 3)
            property float opacity
            property float scale_0
            property float scale_1
            property float scale_2
            property float rot_0
            property float rot_1
            property float rot_2
            property float rot_3
            end_header

        Each vertex (Gaussian) is stored as a contiguous block of float32 values.

    Compatibility:
        The output format is compatible with:
        - Original 3DGS SIBR viewer
        - gsplat library
        - antimatter15/splat web viewer
        - SuperSplat
        - Luma AI

    Example:
        &gt;&gt;&gt; # Export trained Gaussians
        &gt;&gt;&gt; means = np.random.randn(1000, 3).astype(np.float32)
        &gt;&gt;&gt; scales = np.random.randn(1000, 3).astype(np.float32) * 0.1
        &gt;&gt;&gt; rotations = np.zeros((1000, 4), dtype=np.float32)
        &gt;&gt;&gt; rotations[:, 0] = 1.0  # Identity quaternions
        &gt;&gt;&gt; sh_coeffs = np.random.randn(1000, 1, 3).astype(np.float32) * 0.5
        &gt;&gt;&gt; opacities = np.random.rand(1000).astype(np.float32)
        &gt;&gt;&gt; save_gaussian_ply(means, scales, rotations, sh_coeffs, opacities,
        ...                   &#34;output/gaussians.ply&#34;)

        &gt;&gt;&gt; # With higher-degree SH
        &gt;&gt;&gt; sh_coeffs_full = np.random.randn(1000, 16, 3).astype(np.float32) * 0.1
        &gt;&gt;&gt; save_gaussian_ply(means, scales, rotations, sh_coeffs_full, opacities,
        ...                   &#34;output/gaussians_sh3.ply&#34;)
    &#34;&#34;&#34;
    from plyfile import PlyData, PlyElement

    # 1. Validate inputs
    n_gaussians = validate_gaussian_attributes(means, scales, rotations, sh_coeffs, opacities)

    # 2. Create output directory if needed
    filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)

    # 3. Prepare data - ensure float32 and correct shapes
    means = means.astype(np.float32)
    scales = scales.astype(np.float32)
    rotations = rotations.astype(np.float32)
    sh_coeffs = sh_coeffs.astype(np.float32)

    # Flatten opacities
    if opacities.ndim == 2:
        opacities = opacities.squeeze(-1)
    opacities = opacities.astype(np.float32)

    # Normalize quaternions
    quat_norm = np.linalg.norm(rotations, axis=1, keepdims=True)
    rotations = rotations / (quat_norm + 1e-8)

    # 4. Determine SH degree and prepare SH data
    num_sh_coeffs = sh_coeffs.shape[1]
    sh_degree = int(np.sqrt(num_sh_coeffs)) - 1

    # Flatten SH coefficients: (N, num_coeffs, 3) -&gt; separate DC and rest
    # DC term: first coefficient, 3 channels
    f_dc = sh_coeffs[:, 0, :]  # (N, 3)

    # Rest terms: remaining coefficients, 3 channels each
    if num_sh_coeffs &gt; 1:
        f_rest = sh_coeffs[:, 1:, :].reshape(n_gaussians, -1)  # (N, (num_coeffs-1)*3)
    else:
        f_rest = np.zeros((n_gaussians, 0), dtype=np.float32)

    # 5. Build structured array dtype
    dtype_list = [
        (&#39;x&#39;, &#39;f4&#39;), (&#39;y&#39;, &#39;f4&#39;), (&#39;z&#39;, &#39;f4&#39;),
        (&#39;nx&#39;, &#39;f4&#39;), (&#39;ny&#39;, &#39;f4&#39;), (&#39;nz&#39;, &#39;f4&#39;),  # Normals (set to 0)
        (&#39;f_dc_0&#39;, &#39;f4&#39;), (&#39;f_dc_1&#39;, &#39;f4&#39;), (&#39;f_dc_2&#39;, &#39;f4&#39;),
    ]

    # Add f_rest properties
    num_rest = f_rest.shape[1]
    for i in range(num_rest):
        dtype_list.append((f&#39;f_rest_{i}&#39;, &#39;f4&#39;))

    # Add opacity, scale, rotation
    dtype_list.append((&#39;opacity&#39;, &#39;f4&#39;))
    dtype_list.extend([
        (&#39;scale_0&#39;, &#39;f4&#39;), (&#39;scale_1&#39;, &#39;f4&#39;), (&#39;scale_2&#39;, &#39;f4&#39;),
        (&#39;rot_0&#39;, &#39;f4&#39;), (&#39;rot_1&#39;, &#39;f4&#39;), (&#39;rot_2&#39;, &#39;f4&#39;), (&#39;rot_3&#39;, &#39;f4&#39;),
    ])

    # Add extra attributes
    if extra_attributes:
        for name, arr in extra_attributes.items():
            if arr.ndim == 1:
                dtype_list.append((f&#39;extra_{name}&#39;, &#39;f4&#39;))
            else:
                for i in range(arr.shape[1]):
                    dtype_list.append((f&#39;extra_{name}_{i}&#39;, &#39;f4&#39;))

    # 6. Create structured array
    vertices = np.zeros(n_gaussians, dtype=dtype_list)

    # Fill in data
    vertices[&#39;x&#39;] = means[:, 0]
    vertices[&#39;y&#39;] = means[:, 1]
    vertices[&#39;z&#39;] = means[:, 2]

    # Normals (set to 0, not used by most viewers)
    vertices[&#39;nx&#39;] = 0
    vertices[&#39;ny&#39;] = 0
    vertices[&#39;nz&#39;] = 0

    # DC color terms
    vertices[&#39;f_dc_0&#39;] = f_dc[:, 0]
    vertices[&#39;f_dc_1&#39;] = f_dc[:, 1]
    vertices[&#39;f_dc_2&#39;] = f_dc[:, 2]

    # Rest SH terms
    for i in range(num_rest):
        vertices[f&#39;f_rest_{i}&#39;] = f_rest[:, i]

    # Opacity
    vertices[&#39;opacity&#39;] = opacities

    # Scales (keep in log-space as per 3DGS format)
    vertices[&#39;scale_0&#39;] = scales[:, 0]
    vertices[&#39;scale_1&#39;] = scales[:, 1]
    vertices[&#39;scale_2&#39;] = scales[:, 2]

    # Rotations (wxyz format)
    vertices[&#39;rot_0&#39;] = rotations[:, 0]  # w
    vertices[&#39;rot_1&#39;] = rotations[:, 1]  # x
    vertices[&#39;rot_2&#39;] = rotations[:, 2]  # y
    vertices[&#39;rot_3&#39;] = rotations[:, 3]  # z

    # Extra attributes
    if extra_attributes:
        for name, arr in extra_attributes.items():
            if arr.ndim == 1:
                vertices[f&#39;extra_{name}&#39;] = arr
            else:
                for i in range(arr.shape[1]):
                    vertices[f&#39;extra_{name}_{i}&#39;] = arr[:, i]

    # 7. Write PLY file
    el = PlyElement.describe(vertices, &#39;vertex&#39;)
    PlyData([el], text=False).write(str(filepath))</code></pre>
</details>
<div class="desc"><p>Save Gaussian splats to PLY file format.</p>
<p>Exports trained Gaussian parameters to a binary PLY file compatible
with standard 3D Gaussian Splatting viewers and renderers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>means</code></strong></dt>
<dd>Gaussian center positions in world coordinates.
Shape: (N, 3)
dtype: float32
Units: Meters
Columns: [x, y, z]</dd>
<dt><strong><code>scales</code></strong></dt>
<dd>Log-scale parameters for each axis.
Shape: (N, 3)
dtype: float32
Range: Typically [-10, 2] in log-space
Note: Actual scale = exp(scales)
Columns: [scale_x, scale_y, scale_z]</dd>
<dt><strong><code>rotations</code></strong></dt>
<dd>Rotation quaternions in (w, x, y, z) format.
Shape: (N, 4)
dtype: float32
Should be normalized (||q|| = 1)
Columns: [rot_w, rot_x, rot_y, rot_z]</dd>
<dt><strong><code>sh_coeffs</code></strong></dt>
<dd>
<p>Spherical harmonic coefficients for color.
Shape: (N, num_coeffs, 3) where num_coeffs = (degree+1)²
dtype: float32
For degree 0: shape (N, 1, 3) - DC term only
For degree 3: shape (N, 16, 3) - full SH</p>
<p>The DC term (sh_coeffs[:, 0, :]) encodes base color.
Higher-order terms encode view-dependent effects.</p>
</dd>
<dt><strong><code>opacities</code></strong></dt>
<dd>Opacity values after sigmoid activation.
Shape: (N,) or (N, 1)
dtype: float32
Range: [0, 1] (already activated, not logits)</dd>
<dt><strong><code>filepath</code></strong></dt>
<dd>Output path for the PLY file.
Will create parent directories if needed.
Should have .ply extension.</dd>
<dt><strong><code>extra_attributes</code></strong></dt>
<dd>Optional dictionary of additional per-Gaussian attributes.
Keys: Attribute names (will be prefixed with "extra_")
Values: np.ndarray of shape (N,) or (N, k)
Default: None</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If input shapes are incompatible.</dd>
<dt><code>IOError</code></dt>
<dd>If file cannot be written.</dd>
</dl>
<p>File Format:
The PLY file contains a header followed by binary vertex data.</p>
<pre><code>Header example:
    ply
    format binary_little_endian 1.0
    element vertex &lt;N&gt;
    property float x
    property float y
    property float z
    property float f_dc_0
    property float f_dc_1
    property float f_dc_2
    property float f_rest_0
    ... (up to f_rest_44 for degree 3)
    property float opacity
    property float scale_0
    property float scale_1
    property float scale_2
    property float rot_0
    property float rot_1
    property float rot_2
    property float rot_3
    end_header

Each vertex (Gaussian) is stored as a contiguous block of float32 values.
</code></pre>
<h2 id="compatibility">Compatibility</h2>
<p>The output format is compatible with:
- Original 3DGS SIBR viewer
- gsplat library
- antimatter15/splat web viewer
- SuperSplat
- Luma AI</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Export trained Gaussians
&gt;&gt;&gt; means = np.random.randn(1000, 3).astype(np.float32)
&gt;&gt;&gt; scales = np.random.randn(1000, 3).astype(np.float32) * 0.1
&gt;&gt;&gt; rotations = np.zeros((1000, 4), dtype=np.float32)
&gt;&gt;&gt; rotations[:, 0] = 1.0  # Identity quaternions
&gt;&gt;&gt; sh_coeffs = np.random.randn(1000, 1, 3).astype(np.float32) * 0.5
&gt;&gt;&gt; opacities = np.random.rand(1000).astype(np.float32)
&gt;&gt;&gt; save_gaussian_ply(means, scales, rotations, sh_coeffs, opacities,
...                   &quot;output/gaussians.ply&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # With higher-degree SH
&gt;&gt;&gt; sh_coeffs_full = np.random.randn(1000, 16, 3).astype(np.float32) * 0.1
&gt;&gt;&gt; save_gaussian_ply(means, scales, rotations, sh_coeffs_full, opacities,
...                   &quot;output/gaussians_sh3.ply&quot;)
</code></pre></div>
</dd>
<dt id="ply_exporter.validate_gaussian_attributes"><code class="name flex">
<span>def <span class="ident">validate_gaussian_attributes</span></span>(<span>means: np.ndarray,<br>scales: np.ndarray,<br>rotations: np.ndarray,<br>sh_coeffs: np.ndarray,<br>opacities: np.ndarray) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_gaussian_attributes(
    means: np.ndarray,
    scales: np.ndarray,
    rotations: np.ndarray,
    sh_coeffs: np.ndarray,
    opacities: np.ndarray,
) -&gt; int:
    &#34;&#34;&#34;
    Validate shapes and types of Gaussian attributes.

    Args:
        means: Position array to validate.
        scales: Scale array to validate.
        rotations: Rotation quaternion array to validate.
        sh_coeffs: SH coefficient array to validate.
        opacities: Opacity array to validate.

    Returns:
        int: Number of Gaussians (N) if valid.

    Raises:
        ValueError: If any array has incorrect shape or type.
    &#34;&#34;&#34;
    # Check means
    if means.ndim != 2 or means.shape[1] != 3:
        raise ValueError(f&#34;means must have shape (N, 3), got {means.shape}&#34;)
    n_gaussians = means.shape[0]

    # Check scales
    if scales.ndim != 2 or scales.shape[1] != 3:
        raise ValueError(f&#34;scales must have shape (N, 3), got {scales.shape}&#34;)
    if scales.shape[0] != n_gaussians:
        raise ValueError(f&#34;scales has {scales.shape[0]} rows, expected {n_gaussians}&#34;)

    # Check rotations
    if rotations.ndim != 2 or rotations.shape[1] != 4:
        raise ValueError(f&#34;rotations must have shape (N, 4), got {rotations.shape}&#34;)
    if rotations.shape[0] != n_gaussians:
        raise ValueError(f&#34;rotations has {rotations.shape[0]} rows, expected {n_gaussians}&#34;)

    # Check sh_coeffs
    if sh_coeffs.ndim != 3 or sh_coeffs.shape[2] != 3:
        raise ValueError(f&#34;sh_coeffs must have shape (N, num_coeffs, 3), got {sh_coeffs.shape}&#34;)
    if sh_coeffs.shape[0] != n_gaussians:
        raise ValueError(f&#34;sh_coeffs has {sh_coeffs.shape[0]} rows, expected {n_gaussians}&#34;)

    # Validate SH degree
    num_coeffs = sh_coeffs.shape[1]
    valid_counts = [1, 4, 9, 16]  # (degree+1)^2 for degrees 0-3
    if num_coeffs not in valid_counts:
        raise ValueError(f&#34;sh_coeffs has {num_coeffs} coefficients, expected one of {valid_counts}&#34;)

    # Check opacities
    if opacities.ndim == 2:
        opacities = opacities.squeeze(-1)
    if opacities.ndim != 1:
        raise ValueError(f&#34;opacities must have shape (N,) or (N, 1), got shape with {opacities.ndim} dims&#34;)
    if opacities.shape[0] != n_gaussians:
        raise ValueError(f&#34;opacities has {opacities.shape[0]} elements, expected {n_gaussians}&#34;)

    return n_gaussians</code></pre>
</details>
<div class="desc"><p>Validate shapes and types of Gaussian attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>means</code></strong></dt>
<dd>Position array to validate.</dd>
<dt><strong><code>scales</code></strong></dt>
<dd>Scale array to validate.</dd>
<dt><strong><code>rotations</code></strong></dt>
<dd>Rotation quaternion array to validate.</dd>
<dt><strong><code>sh_coeffs</code></strong></dt>
<dd>SH coefficient array to validate.</dd>
<dt><strong><code>opacities</code></strong></dt>
<dd>Opacity array to validate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of Gaussians (N) if valid.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If any array has incorrect shape or type.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ply_exporter.construct_ply_header" href="#ply_exporter.construct_ply_header">construct_ply_header</a></code></li>
<li><code><a title="ply_exporter.get_sh_coefficient_count" href="#ply_exporter.get_sh_coefficient_count">get_sh_coefficient_count</a></code></li>
<li><code><a title="ply_exporter.load_gaussian_ply" href="#ply_exporter.load_gaussian_ply">load_gaussian_ply</a></code></li>
<li><code><a title="ply_exporter.save_gaussian_ply" href="#ply_exporter.save_gaussian_ply">save_gaussian_ply</a></code></li>
<li><code><a title="ply_exporter.validate_gaussian_attributes" href="#ply_exporter.validate_gaussian_attributes">validate_gaussian_attributes</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
